# rsa-hard

**Category**: crypto

**Points**: 350

i fucking hate crypto.

## Files

- [chall.py](./chall.py)
- [chall.txt](./chall.txt)

## Solution

hints posted in the discord:

1. `If the gcd(e1, e2) is equal to 1, then, according to Bezout's identity, there exist integers a and b such that their linear combination a * e1 + b * e2 = 1.`
2. `extended-euclid-gcd`

using https://bitsdeep.com/posts/attacking-rsa-for-fun-and-ctf-points-part-1/ you can figure out that Bezout's identity has to be used, which can be done using the extended Euclidean algorithm.

following hint 1 -

```
c1 = m ^ e1 (mod n) ==> c1 ^ a = m ^ (e1 * a) (mod n)
c2 = m ^ e2 (mod n) ==> c2 ^ b = m ^ (e2 * b) (mod n)
c1 * c2 = m ^ (e1 * a + e2 * b) (mod n) = m ^ 1 (mod n)
```

here is the solution script, `extended-euclid-gcd` implementation taken from https://www.rookieslab.com/posts/extended-euclid-algorithm-to-find-gcd-bezouts-coefficients-python-cpp-code

```python
import gmpy2

n = 18865659016297550078093481750444291325661419955754740601365060640466936009021793706730721610539350223773398787694174265754743567754058369162862278209406578783754388774393442185997588856439260987569993705462606752207711776371237042687890634068033431896622336904805084723493232219406791321018097238901590082829264339223741820245223767242735735957232946690009595614765670372886727618441068057684118889783920169139005717615560410475436166143710857489003138819288426224800754846008179603129725236505401940391705384900856717784619204434534387775312638439841603524109174686692816398557850066651932221093851297006371499990967
e1 = 32
e2 = 94
c1 = 14445417002070743146022567793837267115143684435011596763833168097558856249109790830926963039082980259030060728165401703049422076718675793522687079715998221229473245439332618613325722721097233147409229630488006930544688880087081173178847897699052512229740646154133318372046343043376674558881369526764219176257737447425164552001785181626036139817603417392470060879818834912984529698418710654968646482392875679371568950980647232046002998857685958533981372016585368799307349100581625831560656772569407658314445623901184849265175935950641913879673850289072045175970593884394263609055155641862971918806752206893464905600329
c2 = 10715414790712724098169884933896531926423280265119386389475373855636702296241129831159230933935775028416977632089338943360258745054981400626125328134755164887047616027140696034459487787446204444988140086213451548476169955673669788988429939914704014737324040522794519475397298633898189697760259210614433672570160563703838347640948311871289983617418420263102342601893773759942988446413317468979175688246217107025634499906759043311374943095312564499340543816784944144590203213371489661476594453294232788649180583101865584953988576170122089550550798693726980766806637304029514200025262640601020010103983047739930474652155


def extended_euclid_gcd(a, b):
    """
    Returns a list `result` of size 3 where:
    Referring to the equation ax + by = gcd(a, b)
        result[0] is gcd(a, b)
        result[1] is x
        result[2] is y
    """
    s = 0
    old_s = 1
    t = 1
    old_t = 0
    r = b
    old_r = a

    while r != 0:
        quotient = old_r // r
        old_r, r = r, old_r - quotient * r
        old_s, s = s, old_s - quotient * s
        old_t, t = t, old_t - quotient * t
    return [old_r, old_s, old_t]


# ax + by = 1
gcd, x, y = extended_euclid_gcd(e1 // 2, e2 // 2)
m = (pow(c1, x, n) * pow(c2, y, n)) % n
m = gmpy2.iroot(m, 2)[0]  # square root
hex = hex(m)[2:]  # remove 0x
print(bytes.fromhex(hex).decode("utf-8"))  # convert to ascii
```
